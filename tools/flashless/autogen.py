"""Automatic manifest/fixture generation for zero-config flashless."""

from __future__ import annotations

import json
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable

from .errors import FlashlessError

_WEB_SUFFIXES = {".html", ".js", ".css", ".png", ".svg", ".jpg", ".jpeg", ".ico", ".webp"}
_IGNORED_DIRS = {".git", "__pycache__", ".pytest_cache"}


@dataclass(frozen=True)
class AutoBootstrapResult:
    manifest_path: Path
    fixtures_dir: Path
    asset_root: Path


def generate_auto_manifest(project_dir: Path, auto_dir: Path) -> AutoBootstrapResult:
    asset_root = _discover_asset_root(project_dir)
    if asset_root is None:
        raise FlashlessError(
            "Could not auto-discover frontend assets. Add a manifest with '--manifest' or include an index.html in project assets."
        )

    api_routes, ui_routes = _discover_http_routes(project_dir)
    if "/" not in ui_routes:
        ui_routes.insert(0, "/")

    required_files = _discover_required_files(asset_root)

    fixtures_dir = auto_dir / "fixtures"
    fixtures_dir.mkdir(parents=True, exist_ok=True)

    api_map = []
    for route in api_routes:
        fixture_name = _fixture_name(route.method, route.path)
        fixture_payload = {
            "ok": True,
            "method": route.method,
            "path": route.path,
            "autoGenerated": True,
        }
        (fixtures_dir / fixture_name).write_text(json.dumps(fixture_payload), encoding="utf-8")
        api_map.append(
            {
                "method": route.method,
                "path": route.path,
                "fixture": fixture_name,
                "status": 200,
                "headers": {"Content-Type": "application/json"},
            }
        )

    manifest = {
        "version": "1",
        "ui": {
            "basePath": "/",
            "assetRoot": str(asset_root.relative_to(project_dir)),
            "entryFile": "index.html",
            "routes": ui_routes,
            "spaFallback": True,
            "cachePolicy": {
                "maxAgeSeconds": 0,
                "etag": True,
                "gzip": False,
            },
        },
        "api": {
            "mode": "mock",
            "fixturesDir": str(fixtures_dir),
            "map": api_map,
        },
        "validation": {
            "requiredFiles": required_files,
            "disallowExtraRoutes": False,
        },
    }

    manifest_path = auto_dir / "flashless.manifest.json"
    manifest_path.parent.mkdir(parents=True, exist_ok=True)
    manifest_path.write_text(json.dumps(manifest, indent=2), encoding="utf-8")

    return AutoBootstrapResult(
        manifest_path=manifest_path,
        fixtures_dir=fixtures_dir,
        asset_root=asset_root,
    )


@dataclass(frozen=True)
class _Route:
    method: str
    path: str


def _discover_asset_root(project_dir: Path) -> Path | None:
    cmake_candidates = _candidates_from_cmake(project_dir)
    if cmake_candidates:
        return max(cmake_candidates, key=_asset_root_score)

    fs_candidates: list[Path] = []
    for path in _iter_project_files(project_dir):
        if path.name != "index.html":
            continue
        fs_candidates.append(path.parent)

    if fs_candidates:
        return max(fs_candidates, key=_asset_root_score)

    return None


def _candidates_from_cmake(project_dir: Path) -> list[Path]:
    candidates: list[Path] = []
    pattern = re.compile(r"EMBED_(?:TXT)?FILES\s+([^)]+)\)", re.MULTILINE | re.DOTALL)
    for cmake in _iter_project_files(project_dir):
        if cmake.name != "CMakeLists.txt":
            continue

        text = cmake.read_text(encoding="utf-8", errors="ignore")
        for match in pattern.finditer(text):
            block = match.group(1)
            rel_paths = re.findall(r"\"([^\"]+)\"", block)
            resolved = []
            for rel in rel_paths:
                candidate = (cmake.parent / rel).resolve()
                if candidate.is_file() and candidate.suffix.lower() in _WEB_SUFFIXES:
                    resolved.append(candidate)
            if not resolved:
                continue

            roots = [p.parent for p in resolved]
            common = _common_parent(roots)
            if common is None:
                continue
            if (common / "index.html").exists():
                candidates.append(common)

    return _unique_paths(candidates)


def _discover_http_routes(project_dir: Path) -> tuple[list[_Route], list[str]]:
    api_routes: list[_Route] = []
    ui_routes: list[str] = []

    uri_block = re.compile(r"httpd_uri_t\s+\w+\s*=\s*\{(.*?)\};", re.DOTALL)
    uri_re = re.compile(r"\.uri\s*=\s*\"([^\"]+)\"")
    method_re = re.compile(r"\.method\s*=\s*([A-Z0-9_]+)")
    ws_re = re.compile(r"\.is_websocket\s*=\s*true")

    for source in _iter_project_files(project_dir):
        if source.suffix not in {".c", ".cpp", ".h", ".hpp"}:
            continue

        text = source.read_text(encoding="utf-8", errors="ignore")
        for block in uri_block.findall(text):
            uri_m = uri_re.search(block)
            if uri_m is None:
                continue

            path = _normalize_route(uri_m.group(1))
            if not path:
                continue
            if ws_re.search(block):
                continue

            method_token = "HTTP_GET"
            method_m = method_re.search(block)
            if method_m is not None:
                method_token = method_m.group(1)
            method = _http_method_from_token(method_token)

            if path.startswith("/api/"):
                api_routes.append(_Route(method=method, path=path))
            elif not path.startswith("/ws"):
                ui_routes.append(path)

    ui_routes = sorted(set(ui_routes), key=lambda v: (v != "/", v))
    api_routes = sorted(set(api_routes), key=lambda v: (v.path, v.method))
    return api_routes, ui_routes


def _discover_required_files(asset_root: Path) -> list[str]:
    preferred = ["index.html", "app.js", "styles.css"]
    required = [name for name in preferred if (asset_root / name).exists()]
    if not required:
        required = ["index.html"]

    # Add root-level web assets so strict mode catches missing shipped files.
    for file in sorted(asset_root.iterdir(), key=lambda p: p.name):
        if not file.is_file():
            continue
        if file.suffix.lower() not in _WEB_SUFFIXES:
            continue
        if file.name not in required:
            required.append(file.name)

    return required


def _asset_root_score(path: Path) -> tuple[int, int]:
    files = [p for p in path.iterdir() if p.is_file()]
    web_count = sum(1 for p in files if p.suffix.lower() in _WEB_SUFFIXES)
    has_index = 1 if (path / "index.html").exists() else 0
    return has_index, web_count


def _common_parent(paths: Iterable[Path]) -> Path | None:
    values = [p.resolve() for p in paths]
    if not values:
        return None
    common = values[0]
    for path in values[1:]:
        while common != common.parent and common not in path.parents and common != path:
            common = common.parent
    return common


def _http_method_from_token(token: str) -> str:
    mapping = {
        "HTTP_GET": "GET",
        "HTTP_POST": "POST",
        "HTTP_PUT": "PUT",
        "HTTP_DELETE": "DELETE",
        "HTTP_PATCH": "PATCH",
    }
    return mapping.get(token, "GET")


def _fixture_name(method: str, path: str) -> str:
    clean = path.strip("/").replace("/", "_") or "root"
    clean = re.sub(r"[^a-zA-Z0-9_.-]", "_", clean)
    return f"{method.lower()}_{clean}.json"


def _normalize_route(route: str) -> str:
    value = route.strip()
    if not value:
        return ""
    value = "/" + value.lstrip("/")
    if value != "/" and value.endswith("/"):
        value = value[:-1]
    return value


def _iter_project_files(project_dir: Path) -> Iterable[Path]:
    for path in project_dir.rglob("*"):
        if path.is_dir():
            continue
        if _is_ignored(path.relative_to(project_dir)):
            continue
        yield path


def _is_ignored(rel_path: Path) -> bool:
    for part in rel_path.parts:
        if part in _IGNORED_DIRS:
            return True
        if part == "build" or part.startswith("build_"):
            return True
    return False


def _unique_paths(paths: Iterable[Path]) -> list[Path]:
    seen: set[Path] = set()
    result: list[Path] = []
    for path in paths:
        resolved = path.resolve()
        if resolved in seen:
            continue
        seen.add(resolved)
        result.append(resolved)
    return result
